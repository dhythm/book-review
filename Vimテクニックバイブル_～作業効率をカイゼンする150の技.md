# はじめに

「[Vimテクニックバイブル ～作業効率をカイゼンする150の技](https://www.amazon.co.jp/dp/4774147958/)」のまとめです。  

プラグインを利用したカイゼン手法中心で書かれています。  

まずはデフォルト機能＋αの部分を読み込みました。  
Vim は基本機能でもできることが多いので、まずはそれらを理解したいと思ったからです。  

# TL;DR

- コマンドの再利用を利用する(`<Ctrl-f>`で履歴、`<Ctrl-c>`でコピー)
- 連番生成が便利
- neocomplcache, snippet はぜひ使ったほうがよい

# 本書の内容

## 本書の構成

- Chapter 01 環境設定を改善する
- Chapter 01 ファイル操作を改善する
- Chapter 02 比較・検索方法を改善する
- Chapter 03 作業効率を改善する
- Chapter 04 編集方法を改善する
- Chapter 05 開発効率を改善する
- Chapter 06 記録の取り方を改善する
- Chapter 07 置換処理を改善する
- Chapter 08 入力速度を改善する
- Chapter 09 unite.vimを使いこなす

## デフォルト機能＋αでできること

### 本書を読む前に

#### モードの切替
`gQ`で連続してコマンドを使用できるExモードに切り替わります。  

#### キーマッピングに関する基礎知識  
- map はキーシーケンスを展開したあと、さらに別のマップを適用
- noremap は一度だけ展開

マップ系のオプションには、`<silent>``<unique>``<buffer>``<expr>`が利用できます。

#### 変数
変数にはスコープが存在します。(省略可能)  

接頭子  |スコープ
:--:    |:---
g:      |グローバル
b:      |バッファローカル
w:      |ウィンドウローカル
t:      |タブページローカル
s:      |スクリプトローカル
l:      |関数ローカル
v:      |組み込み変数
a:      |関数の引数

オプション名の先頭に'&'をつけると変数として扱うことができるのは初めて知りました。(非常に便利)  
私の環境でコマンドラインモードで下記のコマンドを実行すると、  
```
:let &guifont=substitute(&guifont,"h12","h18","g")
```
「MS_Gothic:h18:cSHIFTJIS」が guifont に設定されます。  

#### ユーザ定義関数
`:function`で定義します。

```
:function! Sum(v1, v2)      " !をつけると、同名関数を上書き
:   return a:v1 + a:v2
:endfunction

:function! s:sum(v1, v2)    " スクリプトローカルの場合は、関数名を小文字にできる
:   return a:v1 + a:v2
:endfunction
```

### 1-4 vimrcで外部の設定ファイルを取り込む

`:source`コマンドを利用して外部の設定ファイルを取り込むことができます。  
条件によって読み込むファイルを変更する方法が便利です。  
```
if has("unix")
    source ~/.vim/unix.vimrc
elseif has("mac")
    source ~/.vim/mac.vimrc
elseif has("win32")
    source ~/.vim/win.vimrc
endif
```

### 1-6 ファイルごとにVimエディタのオプションを設定する

* モードラインとしてよく組み合わされるオプション

オプション  |短縮   |内容
:---        |:--:   |:---
tabstop     |ts     |タブ文字の画面上での幅
shiftwidth  |sw     |インデント時のスペースの幅
softtabstop |sts    |タブ入力時に挿入するスペースの量
textwidth   |tw     |設定された幅で行を改行する
expandtab   |et     |タブを半角スペースに変換して挿入する
wrap        |wrap   |画面端で行を折り返して表示する
fileformat  |ff     |ファイルの改行の種類
filetype    |ft     |ファイルタイプ
readonly    |ro     |ファイルを読み込み専用で開く
foldmethod  |fdm    |折り畳みの形式

### 1-13 autocmdを使用して自動的に処理を実行する

autocommand は Vim 内でイベントが発生すると自動で実行されます。  
下記のように使用します。  
```
:autocmd FileType vim setlocal expandtab shiftwidth=2
```

ファイルを開いたときに編集ファイルのディレクトリに移動する場合は下記のように設定できます。  
```
augroup grlcd
    autocmd!
    autocmd BufEnter * lcd %:p:h
augroup END
```

### 2-7 ファイルの文字コードを変換する

オプション      |処理
:---            |:---
encoding        |Vimが内部処理に使用するエンコーディング
fileencoding    |現在開いているファイルのエンコーディング
fileencodings   |Vimがファイルを開く際に試すエンコーディング群
termencoding    |端末のエンコーディング

エンコーディングを指定して開く場合は、`:e ++enc=utf-8 [filename]`を用います。  

### 3-2 複数の検索パターンに同時にマッチする行を検索する

AND条件は`\&`、OR条件は`\|`が利用できます。  

### 3-3 ビジュアルモードで選択されたテキストのみを対象に置換処理を実行する

`:substitute`コマンドは行単位に実行されるので、矩形選択の領域のみに適用する場合は、`\%V`指定が必要になります。  
```
:'<,'>s/\%Vis/are/
```

### 4-7 履歴を利用して過去に実行したコマンドを再実行する

`q/`、`q?`、`q:`コマンドを利用するとコマンドラインウィンドウから過去の履歴を再実行することができます。  
コマンドラインウィンドウは、コマンドラインモードから`<Ctrl-f>`でも開くことが可能です。  
履歴上で`<Ctrl-c>`を押すと、コマンドラインに履歴がコピーされます。  

* 最後に実行した操作の繰り返し

コマンド|処理
:---    |:---
.       |編集操作
@:      |コマンド
/       |検索
&       |:substituteコマンド
;       |f motion
,       |t motion
@@      |マクロ
:!!     |外部コマンド

### 4-15 名前付きレジスタを編集に活用する

* Vimエディタによる一括処理のフィリたリング結果や抽出データの格納先として利用

```
:g/^/ if line('.') % 4 == 0 | yank A
:g/{pattern}/y A
:let @+ = @a
```

* Vim Script の式のなかでレジスタを利用

```
:yank x                 " レジスタにカレント行をコピー
:put x                  " レジスタをカレント行にペースト
:let @a = 'foo'         " レジスタに値を設定
:call setreg('a','foo') " レジスタに値を設定
:let var = @a           " レジスタの値を参照
:let var = getreg('a')  " レジスタの値を参照
```

### 5-1 インデントを崩さないようにペーストする

`:a[ppend]!`コマンドを実行すると、`autoindent`オプションをトグルした状態でコードを書き込めます。  

### 5-2 複数行の行頭に同じ文字列を挿入する

行末以降の同じ列にテキストを挿入する場合、矩形ビジュアルモードによる仮想編集が便利です。  

```
:set virtualedit=block  " 矩形ビジュアルモードで仮想編集を有効
:set virtualedit=all    " 全てのモードで仮想編集を有効
```

### 5-9 文章を右揃え・中央揃えに整形する

* 右揃え、中央揃えに整形

```
:[range]right {textwidth}   " range で指定した範囲に対して、
:[range]center {textwidth}  " textwidth 幅 or デフォルト(80) で整形
```

* インデントを変更

```
:[range]left {textwidth}    " textwidth 分のスペースを挿入
```

### 5-13 テキストオブジェクトを使用する

`diw`は文字間の空白文字を削除できるため、役立つテキストオブジェクトです。  

### 6-9 使い捨てのシェルスクリプトを無名バッファ上で組み立てる

`:w[rite]`を利用して、バッファの内容を標準入力として外部プログラムを実行できます。  

```text
mv old01.txt new01.txt
mv old02.txt new02.txt
mv old03.txt new03.txt
```
と書いた無名バッファ上で`:w !sh`を実行すると、ファイル名の一括変換処理をおこなえます。  

`:r[ead]`を使用すると外部コマンドの実行結果を読み込めます。  
また各行を複製する方法、行を連結する方法、２行に１行を削除する方法も覚えておくと便利です。  
```
:g/^/t.     " 行を複製
:%norm J    " 行を連結
:%norm jdd  " 行を削除
```

### 7-3 テキストファイルをHTML化する

標準プラグインで定義されている`:TOhtml`コマンドにより、エディタ上の表示をHTMLとしてバッファ出力できます。  
出力されたHTMLファイルはファイルシステム上ではまだ保存されていないので、`:wq`や`ZZ`で保存する必要があります。  

`:TOhtml`は出力する範囲も指定可能です。  

### 7-4 文字数を数える

`g<Ctrl-g>`で文字や単語、バイト数などを確認できます。  
ただし、改行コードがDOSの場合は２文字(CR+LF)として扱われるので、純粋な文字数のカウントにはなりません。  

改行コードを含まない文字数カウントの方法は以下のとおりです。  
```
:%s/.//gn |:noh     " ハイライトのオフも実行
```
### 8-1 複数ファイルを一括で加工する

```
:bufdo {cmd} | :update
```
```
:args sample01.txt sample02.txt ...
:argdo {cmd} | :update
```

* 引数リストを変えずに作業を実施する

`:args`, `:argadd`, `:argdelete`は引数リストを置き換えます。  
別の作業がある、といった理由で引数リストを変更したくない場合は下記のテクニックが使えます。  
```
:split                      " 別ウィンドウ or 別タブを開く
:arglocal                   " argglobal と使い分ける
:argadd sample01.txt ...
:argdo {cmd} | :update
:close
```

### 8-4 Expressionレジスタを使用してVimスクリプトの式の値を取得する

* Expressionレジスタでよく使う関数

```
getline(40)                         " 40行目のテキストを取得
getline('.')                        " カレント行のテキストを取得
getline('.')[10:20]                 " カレント行の10-20文字目を取得
line('.')                           " カレント行の行番号を取得
matchstr(getline('.'),'\d\d\d')     " パターンマッチする箇所のテキストを取得
                                    
@a                                  " レジスタ a の値を取得
getreg('a')                         " 
```

### 8-5 検索にマッチしたテキストをVimスクリプトの式の値で置換する

`submatch()`を利用して、Vimスクリプトによる置換を活用することができます。  
```
:s/\(\d\+\)/[\1]/
```
と同じ処理を、`submatch()`を用いて、  
```
:s/\d\+/\='[' . submatch(1). ']'/
```
で実現できます。  

### 8-6 テキストファイルをソートする

* 指定フィールドのデータでソートする

```
:sort /\%55c/   " 55列目以降の値を参照してソート
```

* パターンにマッチするテキストの値でソートする

```
:sort n /^\([^,]*,\)\{2}/   " 3フィールド目の値を数値と解釈してソート
```

* メールアドレスによるソート

```
:sort r /[^,][^,@]*@[^,]*/  " r オプションはパターンマッチした文字列でソート
:sort n /[^,][^,@]*@[^,]*/  " パターンマッチした文字列"以降"を参照してソート
```

### 8-7 重複する行を削除する

重複行の削除は、`:sort u`で実施できますが、もっと高度な重複削除を行いたい場合は下記のテクニックが使えます。  

* 行の一部のみが一致した行を削除する

```
:sort n /\%55c/
:g/^/ if getline('.')[55:57] == getline(line('.') - 1)[55:57] | d
```
`\%c`の詳細や、他のアトムの挙動については`:help pattern-atoms`で確認できます。  

```
:sort n
:g/^/ if matchstr(getline('.'),'\d\+') == matchstr(getline(line('.')-1),'\d\+') | d
```

### 8-10 一覧の並び順を入れ替える

行の順番を入れ替える場合は、以下の方法で実現できます。  

```
:120,124g/^/ m119
```

グローバルコマンドは各行に実行されるので、120行目が119行目の後ろに移動し、その次に121行目が119行目の後ろに移動し…、と順番が入れ替わります。  

### 8-11 連番を生成する

テキストを作成している際に連番を生成したい場面はよくあると思います。  
Vimには様々なパターンの連番生成方法があります。  

```
:put! =range(1,100)             " 縦方向
:put! =join(range(1,100),' ')   " 横方向
```

* 文章の特定の位置に連番を追加

```
:g/^/ s/,/\=', ' . line('.')/   " 最初の , の後ろに追加
:g/^/ s/\%13c/\=line('.')/      " 13列目に追加
:%norm f,a^R=line('.')^M        " , の後ろに追加
```

* 正規表現を使って連番を追加

```
:g/^/ s/\d\+/\=submatch(0) + line('.') - 1/
:2,$g/^/ s/\d\+/\=matchstr(getline(line('.')-1),'\d\+') + 1/
```

上記のコマンドは、SQL形式のデータのid番号を連番にしたい場合などに便利です。  
```text
insert into USER values ('1', 'name', 'profile');
insert into USER values ('1', 'name', 'profile');
insert into USER values ('1', 'name', 'profile');
↓
insert into USER values ('1', 'name', 'profile');
insert into USER values ('2', 'name', 'profile');
insert into USER values ('3', 'name', 'profile');
```

* Vimの移動コマンドを使って既存の文書の連番を修正する

```
:let c = 483
:g/^/ let c += 1 | normal 3/\d\+^Mc//e^M^R=c^M
```

`:normal`コマンドでは、`3/\d\+^M`で４番目の数値上にカーソルが移動します。  
[実践Vimの書評](https://github.com/dhythm/book-review/blob/master/%E5%AE%9F%E8%B7%B5Vim_%E6%80%9D%E8%80%83%E3%81%AE%E3%82%B9%E3%83%94%E3%83%BC%E3%83%89%E3%81%A7%E7%B7%A8%E9%9B%86%E3%81%97%E3%82%88%E3%81%86%EF%BC%81.md)にも記載がありますが、`:normal`は実行する前にカーソルをその行の先頭に移動します。そのため、必ず４番目の数値に対して処理が可能です。  
`c//e^M`は`c/\d\+/e^M`となるので、４番目の文字の末尾までを変更できます。  
最後にExpressionレジスタからペーストを実施しています。  

### 8-12 条件にマッチする行にだけVimのコマンドを実行する

`:global`や`vglobal`を利用して条件付きの処理を実行できます。  

```
:g/{pattern}/ if {expr} | {cmd}
:g/{pattern}/ if {expr} | if {expr} | {cmd}
```

`:if`で使用しやすい条件式として３パターン挙げられています。  
```
:if getline('.') =~ 'pattern' | {cmd}   " =~は正規表現との比較
:if getline('.') !~ 'pattern' | {cmd}   " !~は正規表現との比較
:if line('.') % 2 == 0 | {cmd}          " 偶数行で処理
```
実行例は以下のとおりです。  
```
" YYYY-MM-DD というフォーマットの行頭に'DATE:'を挿入
:g/^/ if getline('.') =~ '\d\{4\}-\d\d-\d\d' | s/^/DATE:/

" コメント行以外をコメントアウトする
:80,110g/^/ if getline('.') !~ '^#' | s/^/#/

" ５行置きに行テキストを削除
:g/^/ if line('.') % 5 == 0 | normal ^D
```

文字列をExコマンドとして実行する`:execute "{wx_command}"`や、`:let {varname} = {expr} | {cmd}`も、`:normal`同様に`:if`コマンドと相性がよいです。  

### 9-1 短縮入力を使用して入力量を減らす

```
:inorea[bbrev] {lhs} {rhs}  " 挿入モードで有効
:cnorea[bbrev] {lhs} {rhs}  " コマンドラインモードで有効
:norea[bbrev] {lhs} {rhs}   " 双方で有効
```

### 9-2 コマンドにマップを定義してプラグインの機能を実行しやすくする

```
:no[remap]  {lhs} {rhs}     " マップを設定
:nn[oremap] {lhs} {rhs}     " ノーマルモードのマップを設定
:vn[oremap] {lhs} {rhs}     " ビジュアルモードのマップを設定
:ino[remap] {lhs} {rhs}     " 挿入モードのマップを設定
:cno[remap] {lhs} {rhs}     " コマンドラインモードのマップを設定
```

Vimの式を実行するマップを設定する場合、Expressionレジスタを利用するか、`<expr>`を指定します。  
```
:nnoremap <F2> a<C-R>=strftime("%c")<CR><Esc>
:nnoremap <expr> <F2> 'a'. strftime("%c"). '<CR><Esc>'
```

### 9-3 ユーザ定義コマンドを設定する

```
:command! [{属性}...] {コマンド名} {実行したい処理}
```
で設定します。  
コマンド名はアルファベット大文字で始まる必要があります。  

ユーザ定義コマンドは簡単な処理を呼び出すのに適していますが、複雑な処理を実現しようとする場合は、ファンクションを定義します。  
ユーザコマンドからファンクションを呼び出すことも可能です。  





## 便利なプラグインによるカイゼンテクニック

### 4-14 インデント量の違いをハイライト表示する

[indent-guides プラグイン](https://github.com/nathanaelkane/vim-indent-guides)を用いることでインデント幅の違いを視覚化することができます。  

vimrc に設定を入れることで有効にします。  
```
let g:indent_guides_enable_on_vim_startup = 1
```

### 5-6 全角文字を半角文字に変換する

hz_ja.vim plugin は、アルファベット、日本語カタカナ、記号の全角半角を変換できるプラグインです。  
KaoriYa-Vim には標準で入っているので便利です。  

```
:[range]Zenkaku
:[range]Hankaku
```

### 9-10 neocomplcacheを使用して自動補完する

[neocomplcache](https://github.com/Shougo/neocomplcache)を利用すると、補完キーを幼くても自動的に補完が呼び出されます。  
非常に便利なので導入する価値があります。  

起動時に有効にするには、vimrcに下記の設定を追加します。  
```
let g:neocomplcache_enable_at_startup = 1
```

### 9-13 neocomplcacheを使用してスニペット展開を行う

スニペット展開のためのキーマッピングが必要になります。  
```
imap <C-k>  <Plug>(neocomplcache_snippets_expand)
smap <C-k>  <Plug>(neocomplcache_snippets_expand)
```

### 9-14 neocomplcacheのスニペットを自作する

neocomplcacheにはスニペット機能が内蔵されています。  
よく使う定型文は自作のスニペットを作成することで作業速度を向上させることができます。  

```
:et g:neocomplcache_snippets_dir = $HOME.'/snippets'
```
のように設定すると、デフォルト＋自作のスニペットが自動的に読み込まれます。  

スニペットファイルは以下のように記載します。
```text
snippet     if
abbr        if endif
prev_word   '^'
    if ${1:condition}
        ${2}
    endif
```

abbr はポップアップメニューに表示される説明用の文字列、prev_word は優先して補完候補を出す文脈の指定です。この二つは省略可能です。  

スニペットの中身はインデントして設定します。  

${1:condition}, ${2}はプレースホルダで、スニペット展開時は${1}に自動的に移動します。  
もう一度`<Plug>(neocomplcache_snippets_expand)`を押すと、${2}に移動します。  
${1:condition}は、デフォルトで condition という単語が挿入されて選択状態になります。  


# おわりに

デフォルト機能でできることだけでもまだまだ知らないことが多く、学べる内容が盛り沢山でした。  
本書には非常に便利なプラグインがたくさん紹介されていますが、まずは環境に依存しないデフォルト機能を自由自在に使いこなせるようになりたいと思います。  

本書で紹介されているテクニックは、ただ読むだけではなく、実際に実行して何が起こっているか、どう処理されているかを理解することが大切です。  

これらの学んだ知識を活かして、作業効率をどんどん上げていきたいと思います。  

